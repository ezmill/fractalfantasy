<!DOCTYPE html>
<html lang="en">

	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>BASED&CONFUSED</title>
		<link rel="stylesheet" href="jsmixtape/main.css">
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Avenir, Helvetica, Arial, Sans-serif;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
			#trackTitle{
			/*width: 200px;*/
			display: inline-block;
			position: relative;
			white-space: nowrap;
			}
			#titleContainer{
			display: inline-block;
			width: 200px;
			overflow: hidden;
			}

		</style>
	</head>
	<body>

		<script src="jsmixtape/DetectorMixtape.js"></script>
		<script src="js/RequestAnimationFrame.js"></script>
		<script src="js/Stats.js"></script>
		<script src="js/Three.js"></script>
		<script type="text/javascript">
		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-86951-7']);
		  _gaq.push(['_trackPageview']);

		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
		  })();
		</script>
		<script id="vs" type="x-shader/x-vertex">

			uniform sampler2D map;

			uniform float width;
			uniform float height;
			uniform float nearClipping, farClipping;

			varying vec2 vUv;

			const float XtoZ = 1.11146; // tan( 1.0144686 / 2.0 ) * 2.0;
			const float YtoZ = 0.83359; // tan( 0.7898090 / 2.0 ) * 2.0;

			void main() {

				vUv = vec2( position.x / width, 1.0 - ( position.y / height ) );

				vec4 color = texture2D( map, vUv );
				float depth = ( color.r + color.g + color.b ) / 3.0;

				// Projection code by @kcmic

				float z = ( 1.0 - depth ) * (farClipping - nearClipping) + nearClipping;

				vec4 pos = vec4(
					( position.x / width - 0.5 ) * z * XtoZ,
					( position.y / height - 0.5 ) * z * YtoZ,
					- z + 1000.0,
					1.0);

				gl_PointSize = 2.0;
				gl_Position = projectionMatrix * modelViewMatrix * pos;

			}

		</script>
		<script id="fs" type="x-shader/x-fragment">

			uniform sampler2D map;

			varying vec2 vUv;

			void main() {

				vec4 color = texture2D( map, vUv );
				gl_FragColor = vec4( color.r, color.g, color.b, smoothstep( 8000.0, -8000.0, gl_FragCoord.z / gl_FragCoord.w ) );

			}

		</script>
		<script id="warpVs">
		    varying vec2 vUv;
		    // uniform float time;
		    void main() {
		        vUv = uv;
		        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		    }
		</script>
		<script id="warpFs">
			uniform sampler2D tex;
			// uniform sampler2D sinjin;
			uniform sampler2D tex2;
			uniform vec2 resolution;
			uniform float time;
		    varying vec2 vUv;

			void main(){
			    float warpSpeed = 0.3;
			    float warpDistance = 0.02;

			    vec2 uv = vUv;
				// vec2 uv = gl_FragCoord.xy / resolution.xy;
			    // uv.y *= -1.0;
			    
			    vec3 offTexX = texture2D(tex2, uv).rgb;
			    vec3 luma = vec3(0.299, 0.587, 0.114);
			    float power = dot(offTexX, luma);
			    
			    power = sin(3.1415927*2.0 * mod(power + time * warpSpeed, 1.0));
			    
			    gl_FragColor = texture2D(tex, uv+vec2(0, power)*warpDistance);
			    // gl_FragColor = texture2D(tex, vUv);
			    // gl_FragColor = vec4(1.0,0.0,0.0,1.0);
			    
			}
		</script>
		<script id="flowFs">
			uniform sampler2D tex;
			// uniform sampler2D sinjin;
			uniform sampler2D tex2;
			uniform vec2 resolution;
			uniform float time;
		    varying vec2 vUv;

			void main()
			{
				// vec2 p = fragCoord.xy / iResolution.xy;
				
				// vec2 uv = vUv*0.5 + 0.5;
				vec2 uv = vUv;
				
				vec2 e = 1.0/resolution.xy;
				
				
				float am1 = 0.5 + 0.5*sin( time );
				float am2 = 0.5 + 0.5*cos( time );
				
				for( int i=0; i<5; i++ )
				{
					float h  = dot( texture2D(tex, uv,               -100.0).xyz, vec3(0.333) );
					float h1 = dot( texture2D(tex, uv+vec2(e.x,0.0), -100.0).xyz, vec3(0.333) );
					float h2 = dot( texture2D(tex, uv+vec2(0.0,e.y), -100.0).xyz, vec3(0.333) );
			        // gradient
					vec2 g = 0.001*vec2( (h1-h), (h2-h) )/e;
			        // isoline		
					vec2 f = g.yx*vec2(-1.0,1.0);
					
					g = mix( g, f, am1 );
					
					uv -= 0.01*g*am2;
				}
				
				vec3 col = texture2D(tex, uv).xyz;
				
			    // col *= 2.0;
					
				gl_FragColor = vec4(col, 1.0);
			}

		</script>
		<script>

			var container;

			var scene, camera, light, renderer;
			var geometry, cube, mesh, material;
			var mouse, center;
			var stats;
			var outputScene, rtt;
			var time = 0.0;
			var video, texture;

			if ( Detector.webgl ) {

				init();
				animate();

			} else {

				document.body.appendChild( Detector.getWebGLErrorMessage() );

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				// container.appendChild( stats.domElement );

				scene = new THREE.Scene();
				outputScene = new THREE.Scene();
				center = new THREE.Vector3();
				center.z = - 1000;

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 0, 500 );

				scene.add( camera );

				outputCamera = new THREE.OrthographicCamera(window.innerWidth/2, -window.innerWidth/2, window.innerHeight/2, -window.innerHeight/2, -10000,10000)
				outputScene.add(outputCamera);
				outputCamera.position.z = 1;
				// outputCamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );

				// outputCamera.position.set( 0, 0, 500 );
				// outputScene.add(outputCamera);

				rtt = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
				rtt.minFilter = rtt.magFilter = THREE.NearestFilter;
				video = document.createElement( 'video' );
				video.addEventListener( 'loadedmetadata', function ( event ) {

					texture = new THREE.Texture( video );

					var width = 640, height = 480;
					var nearClipping = 850/*850*/, farClipping = 4000/*4000*/;

					geometry = new THREE.Geometry();

					for ( var i = 0, l = width * height; i < l; i ++ ) {
 
						var position = new THREE.Vector3();
						position.x = ( i % width );
						position.y = Math.floor( i / width );

						geometry.vertices.push( new THREE.Vertex( position ) );

					}

					material = new THREE.ShaderMaterial( {

						uniforms: {

							"map": { type: "t", value: 0, texture: texture },
							"width": { type: "f", value: width },
							"height": { type: "f", value: height },
							"nearClipping": { type: "f", value: nearClipping },
							"farClipping": { type: "f", value: farClipping }

						},
						vertexShader: document.getElementById( 'vs' ).textContent,
						fragmentShader: document.getElementById( 'fs' ).textContent,
						depthWrite: false

					} );

					mesh = new THREE.ParticleSystem( geometry, material );
					mesh.position.x = 0;
					mesh.position.y = 0;
					scene.add( mesh );

					setInterval( function () {

						if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

							texture.needsUpdate = true;

						}

					}, 1000 / 30 );


				}, false );
				video.loop = true;
				video.src = 'textures/kinect.mp4';
				video.play();

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				// container.appendChild( renderer.domElement );
				outputRenderer = new THREE.WebGLRenderer();
				outputRenderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( outputRenderer.domElement );
				canvTex = new THREE.Texture(renderer.domElement);

				mouse = new THREE.Vector3( 0, 0, 1 );
				projector = new THREE.Projector();
				ray = new THREE.Ray( camera.position );

				var offsetTex = THREE.ImageUtils.loadTexture("textures/tex07.jpg")
				var otherTex = THREE.ImageUtils.loadTexture("textures/tex04.jpg")
				// outputGeometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
				outputGeometry = new THREE.CubeGeometry(window.innerWidth, window.innerHeight,0);
				outputMaterial = new THREE.ShaderMaterial({
					uniforms: {
						tex: {type: 't', value: 0, texture: canvTex},
						tex2: {type: 't', value: 1, texture: offsetTex},
						time: {type: 'f', value: time},
						resolution: {type: 'v2', value: new THREE.Vector2(window.innerWidth, window.innerHeight)}
					},
					vertexShader: document.getElementById("warpVs").textContent,
					fragmentShader: document.getElementById("warpFs").textContent,
					side:2
				})
				outputMesh = new THREE.Mesh(outputGeometry, outputMaterial);
				outputScene.add(outputMesh);
				outputMesh.position.z = -100;
				// outputMesh.rotation.z = Math.PI;

				// outputScene.add(new THREE.Mesh(new THREE.CubeGeometry(100,100,100), new THREE.MeshBasicMaterial({color:0xff0000})));

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			}

			function onDocumentMouseMove( event ) {

				mouse.x = ( event.clientX - window.innerWidth / 2 ) * 8;
				mouse.y = ( event.clientY - window.innerHeight / 2 ) * 8;

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				canvTex.needsUpdate = true;
				time+= 0.01;
				outputMesh.material.uniforms.tex2.value.needsUpdate = true;
				outputMesh.material.uniforms.time.value = time;
				camera.position.x += ( mouse.x - camera.position.x ) * 0.05;
				camera.position.y += ( - mouse.y - camera.position.y ) * 0.05;
				camera.lookAt( center );

				renderer.render( scene, camera );
				outputRenderer.render( outputScene, outputCamera );

			}

		</script>
		
		<script src="jsmixtape/jquery.min.js"></script>
		<script src="jsmixtape/soundcloudAPI.js"></script>
		<script src="//connect.soundcloud.com/sdk-2.0.0.js"></script>
		<script src="jsmixtape/tracklist.js"></script>
		
		
		
		<div id="audioplayer">
        <button id="pButton" class="play" style="width: 30px; height: 30px;
    	background-size: 100% 100%;left: 15px; bottom: 15px;  "></button>
  		<div id="timeline">
     		 <ul id="credits">
     		 <div class="left">
       			 <li>
            		<b>BASED & CONFUSED</b> | SINJIN HAWKE & ZORA JONES</br>
            		Visual by Ezra Miller <br>
            		<div id="titleContainer">
	            		<span id="trackTitle"></span> 
            		</div>
        		</li>
        	 </div>
        		</center>
      </ul>
      <div id="playhead"></div>
    </div>
        <div id="icons">
               <div id="volume">
          <i class="demo-icon icon-volume-up">&#xe800;</i> 
        </div>
        <div id="half">
          <i class="demo-icon icon-half">&#xe801;</i> 
        </div>
        <div id="mute">
            <i class="demo-icon icon-mute">&#xe802;</i> 
        </div> 
    	</div>
    	</div>
    	
 		<iframe style="display:none;" id="mix" width="100%" height="450" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/219210929&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;visual=true"></iframe>
		
  	<script> //PLAYER SCRIPT//
  	
  var getDuration = function(millis){
    var dur = {};
    var units = [
        {label:"millis",    mod:1000},
        {label:"seconds",   mod:60},
        {label:"minutes",   mod:60},
        {label:"hours",     mod:24},
        {label:"days",      mod:31}
    ];
    // calculate the individual unit values...
    units.forEach(function(u){
        millis = (millis - (dur[u.label] = (millis % u.mod))) / u.mod;
    });
    // convert object to a string representation...
    dur.toString = function(){
        return units.reverse().map(function(u){
            return dur[u.label] + " " + (dur[u.label]==1?u.label.slice(0,-1):u.label);
        }).join(', ');
    };
    return dur;
};
		var duration; // Duration of audio clip
		var pButton = document.getElementById('pButton'); // play button

		var audioplayer = document.getElementById('audioplayer'); // playhead
		var playhead = document.getElementById('playhead'); // playhead

		var timeline = document.getElementById('timeline'); // timeline

		var volume = document.getElementById('volume'); // timeline
		var volumeBar = document.getElementById('volumeBar'); // timeline
		var innerVolume = document.getElementById('innerVolume'); // timeline
		// timeline width adjusted for playhead
		var timelineWidth = window.innerWidth;
		var timelineHeight = 60;
		var counter = 0;
		var volumeBarHeight = 120;
		var volumeAmt = 1.0;
		var trackTitle = document.getElementById("trackTitle");
		var mix = document.getElementById("mix");
		var song;
		var updater;
		SC.initialize({
		  client_id: "cd406b735309b14551e8af7a54c8e6f3"
		});
		SC.stream("/tracks/219210929", {
		  useHTML5Audio: true,
		  preferFlash: false
		}, function(sound) {
		  song = sound;
		  sound._player.on("positionChange", function(state){
		  		update();
		  })
		  pButton.style.display = "block";
		});

		var currentDuration;
		var currentTime;
		var relativePosition;
		var volumeCounter = 0;
		volume.addEventListener("click", function(event){
			// volumeBar.style.display = "block";
			if(volumeCounter%3==0){
				song.setVolume(0.5);
			} else if (volumeCounter%3==1){
				song.setVolume(0.0);
			} else {
				song.setVolume(1.0);
			}
			volumeCounter++;

		})	
		var onvolume = false;
		// volumeBar.addEventListener("click", function(event){
		// 	movevolumehead(event);
		// 	music.volume = volumeAmt * volumeClickPercent(event);
		// })	
		// volumeBar.addEventListener("mousedown", function(event){
		// 	onvolume = true;
		// 	volumeBar.addEventListener('mousemove', movevolumehead, true);
		// })	
		pButton.addEventListener("click", play, true);

		// pButton.addEventListener("touchstart", play);

		// timeline.addEventListener("click", function (event) {
		// 	// console.log(event);
		// 	onplayhead = true;
		// 	moveplayhead(event);
		// }, true);
		timeline.addEventListener("touchstart", function(e){
			e.preventDefault();
			moveplayhead(e);
			onplayhead = true;
			window.addEventListener('touchmove', moveplayhead, true);

		})
		window.addEventListener('touchcancel', function(){
			window.removeEventListener('touchmove', moveplayhead, true);
			onplayhead = false;
		}, false);
		window.addEventListener('touchend', function(){
			window.removeEventListener('touchmove', moveplayhead, true);
			onplayhead = false;
		}, false);
		function clickPercent(e) {
			return (e.pageX - timeline.offsetLeft) / timelineWidth;
		}

		function volumeClickPercent(e) {
			return (((window.innerHeight - e.pageY) - timelineHeight)/volumeBarHeight);
		}

		timeline.addEventListener('mousedown', mouseDown, false);
		window.addEventListener('mouseup', mouseUp, false);

		var onplayhead = false;
		function mouseDown(event) {
			onplayhead = true;
			moveplayhead(event);
			window.addEventListener('mousemove', moveplayhead, true);
			window.addEventListener('touchmove', moveplayhead, true);
		}
		function mouseUp(e) {
			if (onplayhead == true) {
				moveplayhead(e);
				window.removeEventListener('mousemove', moveplayhead, true);
				window.removeEventListener('touchmove', moveplayhead, true);

			}
			onplayhead = false;
		}
		function moveplayhead(e) {
			var newMargLeft = e.pageX - timeline.offsetLeft;
			if (newMargLeft >= 0 && newMargLeft <= timelineWidth) {
				playhead.style.marginLeft = newMargLeft + "px";
			}
			if (newMargLeft < 0) {
				playhead.style.marginLeft = "0px";
			}
			if (newMargLeft > timelineWidth) {
				playhead.style.marginLeft = timelineWidth + "px";
			}
			var newTime = (1 - ((timelineWidth - newMargLeft)/timelineWidth))*currentDuration;
			currentTime = newTime;
			song.seek(currentTime);
		}

		function movevolumehead(e) {
			var newMargTop = ((window.innerHeight - e.pageY) - timelineHeight);
			// var newMargLeft = e.pageX - timeline.offsetLeft;
			if (newMargTop >= 0 && newMargTop <= window.innerHeight) {
				innerVolume.style.marginTop = (120 - newMargTop) + "px";
			}
			if (newMargTop < 0) {
				innerVolume.style.marginTop = "120px";
			}
			if (newMargTop > timelineWidth) {
				innerVolume.style.marginTop = "0px";
			}
		}

		// timeUpdate 
		// Synchronizes playhead position with current point in audio 
		function timeUpdate() {
			// updateTitle();
			// var playPercent = timelineWidth * (music.currentTime / duration);
			// playhead.style.marginLeft = playPercent + "px";
			// if (music.currentTime == duration) {
			// 	pButton.className = "";
			// 	pButton.className = "play";
			// }
		}

		//Play and Pause
		var counter = 0;
		function play() {
			// start music
			// song.isPaused(function(e){
				if(song.getState() !== "playing"){
					song.play();
					// update();
					song.seek(currentTime);
					pButton.className = "";
					pButton.className = "pause";
				} else {
					song.pause();
					// cancelAnimationFrame(updater);
					// updater = null;
					pButton.className = "";
					pButton.className = "play";	
				}
				// song._player._onPositionChange = function(e){

				// }
			// })
			// song.bind(SC.Widget.Events.PLAY, function(e) {
			// 	song.getCurrentSound(function(currentSound){
			// 		currentDuration = currentSound.duration;
			// 		var dur = getDuration(currentSound.duration)
		 //        	var str = dur.minutes + ":" + dur.seconds;
		 //        	// duration.innerHTML = str;
			// 	})
		 //    });
   //  		song.bind(SC.Widget.Events.PLAY_PROGRESS, function(e) {
		 //    	updateTitle();
			// 	currentTime = e.currentPosition;
			// 	var time = getDuration(currentTime);

			// 	if(time.seconds < 10){
			// 		time.seconds = "0" + time.seconds;
			// 	}
			// 	var str = time.minutes + ":" + time.seconds;
			// 	// currentTime.innerHTML = str;

			// 	relativePosition = e.relativePosition;
			// 	playhead.style.marginLeft = (timelineWidth*relativePosition) + "px";
			// });
		}
		function update(){
			// updater = requestAnimationFrame(update);
			currentDuration = song.getDuration();
			var dur = getDuration(currentDuration);
			var str = dur.minutes + ":" + dur.seconds;
			currentTime = song.getCurrentPosition();
			// currentTime = song._player._prevCurrentPosition;
			var time = getDuration(currentTime);

			if(time.seconds < 10){
				time.seconds = "0" + time.seconds;
			}
			var str = time.minutes + ":" + time.seconds;
			// currentTime.innerHTML = str;
			relativePosition = currentTime/currentDuration;
			playhead.style.marginLeft = (timelineWidth*relativePosition) + "px";
			updateTitle();
		}
		function updateTitle(){
			for(var i = 0; i < tracklist.length; i++){
				if(currentTime>(tracklist[i].time)*1000){
					trackTitle.innerHTML = tracklist[i].title
				}
			}
		}

		window.addEventListener("resize", function(){
			timelineWidth = window.innerWidth - 120;
			timeUpdate();
		})


	</script>
	<script> //TEXT SCROLL SCRIPT//

	$(function() {

	    var txt = $("#trackTitle");
	    txt.bind('scroll', function () {
	        var el = $(this);
	        // Scroll state machine
	        var scrollState = el.data("scrollState") || 0;
	        el.data("scrollState", (scrollState + 1) % 4);
	        switch (scrollState) {
	            case 0: // initial wait
	                el.css({ left: 0 });
	                el.show();
	                window.setTimeout(function () {
	                    el.trigger("scroll");
	                }, 5000);
	                break;
	            case 1: // start scroll
	                var delta = el.parent().width() - el.width();
	                if (delta < 0) {
	                    el.animate({ left: delta }, 2000, "linear", function () {
	                        el.trigger("scroll");
	                    });
	                }
	                break;
	            case 2: // delay before scroll back
	                window.setTimeout(function () {
	                    el.trigger("scroll");
	                }, 2000);
	                break;
	            case 3: // fade out
	                el.fadeOut("slow", function () {
	                    el.trigger("scroll");
	                });
	                break;
	        }
	    }).trigger("scroll");
	});
	</script>	
	
	
	
	</body>
</html>